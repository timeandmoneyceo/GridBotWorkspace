"""
Automated File Editor Module

This module automatically applies code diffs and edits generated by the LLM
to source files in a safe and controlled manner.
"""

import os
import shutil
import difflib
import re
import logging
from typing import List, Dict, Optional, Tuple, Union, Any
from dataclasses import dataclass
from datetime import datetime
import tempfile
import ast
import traceback
import textwrap
try:
    # Try relative import first (when run as module)
    from .serena_integration import SerenaMCPClient, SerenaCodeAnalyzer, SerenaCodeEditor, is_serena_available
except ImportError:
    # Fall back to absolute import (when run as script)
    from serena_integration import SerenaMCPClient, SerenaCodeAnalyzer, SerenaCodeEditor, is_serena_available

@dataclass
class EditResult:
    """Container for edit operation results"""
    success: bool
    file_path: str
    changes_made: bool
    backup_path: Optional[str] = None
    error: Optional[str] = None
    diff: Optional[str] = None

class SafeFileEditor:
    """Safe file editor with backup and validation capabilities"""
    
    def __init__(self, backup_dir: Optional[str] = None, validate_syntax: bool = True, 
                 create_backups: bool = True, use_serena: bool = True, 
                 serena_config: Optional[Dict] = None):
        self.backup_dir = backup_dir or "backups"
        self.validate_syntax = validate_syntax
        self.create_backups = create_backups
        self.use_serena = use_serena and is_serena_available()
        self.setup_logging()
        self.ensure_backup_dir()
        
        # Initialize Serena integration
        if self.use_serena:
            try:
                self.serena_client = SerenaMCPClient()
                self.serena_analyzer = SerenaCodeAnalyzer(self.serena_client)
                self.serena_editor = SerenaCodeEditor(self.serena_client, self.serena_analyzer)
                self.logger.info("Serena integration enabled for semantic code editing")
            except Exception as e:
                self.logger.warning(f"Failed to initialize Serena integration: {e}")
                self.use_serena = False
                self.serena_client = None
                self.serena_analyzer = None
                self.serena_editor = None
        else:
            self.serena_client = None
            self.serena_analyzer = None
            self.serena_editor = None
            self.logger.info("Using basic file editing (Serena not available or disabled)")
    
    def setup_logging(self):
        """Setup comprehensive logging for the file editor with detailed terminal output"""
        # Create custom formatter for file editor operations
        class EditorFormatter(logging.Formatter):
            def format(self, record):
                timestamp = self.formatTime(record, '%H:%M:%S')
                if record.levelname == 'INFO':
                    return f"[{timestamp}] EDIT: {record.getMessage()}"
                elif record.levelname == 'ERROR':
                    return f"[{timestamp}] EDIT ERROR: {record.getMessage()}"
                elif record.levelname == 'WARNING':
                    return f"[{timestamp}] EDIT WARN: {record.getMessage()}"
                else:
                    return f"[{timestamp}] EDIT {record.levelname}: {record.getMessage()}"
        
        # Clear any existing handlers to avoid duplicates
        for handler in logging.getLogger(__name__).handlers[:]:
            logging.getLogger(__name__).removeHandler(handler)
        
        # Setup file handler
        file_handler = logging.FileHandler('file_editor.log', encoding='utf-8')
        file_handler.setLevel(logging.INFO)
        file_handler.setFormatter(logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        ))
        
        # Setup console handler with custom formatter and UTF-8 encoding
        console_handler = logging.StreamHandler()
        console_handler.setLevel(logging.INFO)
        console_handler.setFormatter(EditorFormatter())
        
        # Set UTF-8 encoding for console output to handle any Unicode characters
        reconfig = getattr(getattr(console_handler, 'stream', None), 'reconfigure', None)
        if callable(reconfig):
            try:
                reconfig(encoding='utf-8')
            except Exception:
                pass  # Ignore if reconfigure fails
        
        # Configure logger
        self.logger = logging.getLogger(__name__)
        self.logger.setLevel(logging.INFO)
        self.logger.addHandler(file_handler)
        self.logger.addHandler(console_handler)
        self.logger.propagate = False
    
    def ensure_backup_dir(self):
        """Ensure backup directory exists"""
        if not os.path.exists(self.backup_dir):
            os.makedirs(self.backup_dir)
            self.logger.info(f"Created backup directory: {self.backup_dir}")
    
    def create_backup(self, file_path: str) -> str:
        """Create a backup of the file before editing"""
        if not os.path.exists(file_path):
            raise FileNotFoundError(f"File not found: {file_path}")
        
        # Generate backup filename with timestamp
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = os.path.basename(file_path)
        backup_filename = f"{filename}.backup.{timestamp}"
        backup_path = os.path.join(self.backup_dir, backup_filename)
        
        # Copy file to backup location
        shutil.copy2(file_path, backup_path)
        self.logger.info(f"Created backup: {backup_path}")
        
        return backup_path
    
    def validate_python_syntax(self, code: str) -> Tuple[bool, Optional[str]]:
        """Validate Python syntax"""
        if not self.validate_syntax:
            return True, None
        
        try:
            ast.parse(code)
            return True, None
        except SyntaxError as e:
            error_msg = f"Syntax error at line {e.lineno}: {e.msg}"
            return False, error_msg
        except Exception as e:
            error_msg = f"Parse error: {e}"
            return False, error_msg
    
    def apply_code_replacement(self, file_path: str, old_code: str, 
                             new_code: str, context_lines: int = 3) -> EditResult:
        """Apply a code replacement to a file with detailed logging"""
        self.logger.info("=" * 80)
        self.logger.info("STARTING CODE REPLACEMENT")
        self.logger.info("=" * 80)
        self.logger.info(f"File: {file_path}")
        self.logger.info(f"Context lines: {context_lines}")
        self.logger.info(f"Python syntax validation: {self.validate_syntax}")
        self.logger.info(f"Serena integration: {self.use_serena}")
        
        self.logger.info("OLD CODE TO REPLACE:")
        self.logger.info("-" * 40)
        self.logger.info(old_code[:500] + ("..." if len(old_code) > 500 else ""))
        self.logger.info("-" * 40)
        
        self.logger.info("NEW CODE TO INSERT:")
        self.logger.info("-" * 40)
        self.logger.info(new_code[:500] + ("..." if len(new_code) > 500 else ""))
        self.logger.info("-" * 40)
        
        # Try semantic editing with Serena first
        if self.use_serena and self._should_use_semantic_edit(file_path, old_code, new_code):
            self.logger.info("ATTEMPTING SEMANTIC EDIT WITH SERENA")
            semantic_result = self._apply_semantic_edit(file_path, old_code, new_code)
            if semantic_result.success:
                self.logger.info("SEMANTIC EDIT SUCCESSFUL")
                return semantic_result
        
        # Fall back to traditional string replacement
        self.logger.info("USING TRADITIONAL STRING REPLACEMENT")
        return self._apply_traditional_replacement(file_path, old_code, new_code, context_lines)
    
    def apply_diff_patch(self, file_path: str, diff_content: str) -> EditResult:
        """Apply a unified diff patch to a file"""
        try:
            # Create backup first
            backup_path = self.create_backup(file_path)
            
            # Read original file
            with open(file_path, 'r', encoding='utf-8') as f:
                original_lines = f.readlines()
            
            # Parse and apply the diff
            new_lines = self._apply_unified_diff(original_lines, diff_content)
            
            if new_lines is None:
                return EditResult(
                    success=False,
                    file_path=file_path,
                    changes_made=False,
                    backup_path=backup_path,
                    error="Failed to apply diff patch"
                )
            
            new_content = ''.join(new_lines)
            
            # Validate syntax if it's a Python file
            if file_path.endswith('.py'):
                is_valid, syntax_error = self.validate_python_syntax(new_content)
                if not is_valid:
                    return EditResult(
                        success=False,
                        file_path=file_path,
                        changes_made=False,
                        backup_path=backup_path,
                        error=f"Syntax validation failed: {syntax_error}"
                    )
            
            # Write the modified content
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(new_content)
            
            # Generate diff for logging
            diff = self._generate_diff(''.join(original_lines), new_content, file_path)
            
            self.logger.info(f"Successfully applied diff patch to {file_path}")
            
            return EditResult(
                success=True,
                file_path=file_path,
                changes_made=True,
                backup_path=backup_path,
                diff=diff
            )
            
        except Exception as e:
            error_msg = f"Error applying diff patch: {e}"
            self.logger.error(error_msg)
            return EditResult(
                success=False,
                file_path=file_path,
                changes_made=False,
                error=error_msg
            )
    
    def _apply_fuzzy_replacement(self, content: str, old_code: str, new_code: str) -> str:
        """Apply replacement using fuzzy matching"""
        old_lines = old_code.strip().split('\n')
        content_lines = content.split('\n')
        
        # Try to find the best match using difflib
        matcher = difflib.SequenceMatcher(None, content_lines, old_lines)
        
        # Find the best matching subsequence
        match = matcher.find_longest_match(0, len(content_lines), 0, len(old_lines))
        
        if match.size > len(old_lines) * 0.7:  # At least 70% match
            # Replace the matched section
            start_line = match.a
            end_line = match.a + match.size
            
            new_lines = content_lines[:start_line] + new_code.strip().split('\n') + content_lines[end_line:]
            return '\n'.join(new_lines)
        
        return content  # No good match found
    
    def _apply_unified_diff(self, original_lines: List[str], diff_content: str) -> Optional[List[str]]:
        """Apply a unified diff to the original lines"""
        try:
            diff_lines = diff_content.split('\n')
            result_lines = original_lines.copy()

            # Parse diff header to find the line range
            current_line = 0

            for line in diff_lines:
                if line.startswith('@@'):
                    if match := re.match(
                        r'@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@', line
                    ):
                        old_start = int(match[1]) - 1
                        current_line = old_start
                elif line.startswith(' '):
                    # Context line - no change
                    current_line += 1
                elif line.startswith('-'):
                    # Line to remove
                    if current_line < len(result_lines):
                        result_lines.pop(current_line)
                    # Don't increment current_line since we removed a line
                elif line.startswith('+'):
                    # Line to add
                    new_line = line[1:] if line[1:].endswith('\n') else line[1:] + '\n'
                    result_lines.insert(current_line, new_line)
                    current_line += 1

            return result_lines

        except Exception as e:
            self.logger.error(f"Error applying unified diff: {e}")
            return None
    
    def _generate_diff(self, original: str, modified: str, filename: str) -> str:
        """Generate a unified diff between original and modified content"""
        original_lines = original.splitlines(keepends=True)
        modified_lines = modified.splitlines(keepends=True)
        
        diff = difflib.unified_diff(
            original_lines,
            modified_lines,
            fromfile=f"{filename}.original",
            tofile=f"{filename}.modified",
            lineterm=''
        )
        
        return ''.join(diff)
    
    def apply_line_replacement(self, file_path: str, line_number: int, 
                             new_line: str) -> EditResult:
        """Replace a specific line in a file"""
        try:
            # Create backup first
            backup_path = self.create_backup(file_path)
            
            # Read original file
            with open(file_path, 'r', encoding='utf-8') as f:
                lines = f.readlines()
            
            # Check line number validity
            if line_number < 1 or line_number > len(lines):
                return EditResult(
                    success=False,
                    file_path=file_path,
                    changes_made=False,
                    backup_path=backup_path,
                    error=f"Line number {line_number} out of range (1-{len(lines)})"
                )
            
            # Store original content for diff
            original_content = ''.join(lines)
            
            # Replace the line (convert to 0-based index)
            lines[line_number - 1] = new_line if new_line.endswith('\n') else new_line + '\n'
            
            new_content = ''.join(lines)
            
            # Validate syntax if it's a Python file
            if file_path.endswith('.py'):
                is_valid, syntax_error = self.validate_python_syntax(new_content)
                if not is_valid:
                    return EditResult(
                        success=False,
                        file_path=file_path,
                        changes_made=False,
                        backup_path=backup_path,
                        error=f"Syntax validation failed: {syntax_error}"
                    )
            
            # Write the modified content
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(new_content)
            
            # Generate diff for logging
            diff = self._generate_diff(original_content, new_content, file_path)
            
            self.logger.info(f"Successfully replaced line {line_number} in {file_path}")
            
            return EditResult(
                success=True,
                file_path=file_path,
                changes_made=True,
                backup_path=backup_path,
                diff=diff
            )
            
        except Exception as e:
            error_msg = f"Error replacing line: {e}"
            self.logger.error(error_msg)
            return EditResult(
                success=False,
                file_path=file_path,
                changes_made=False,
                error=error_msg
            )
    
    def restore_from_backup(self, file_path: str, backup_path: str) -> bool:
        """Restore a file from its backup"""
        try:
            if not os.path.exists(backup_path):
                self.logger.error(f"Backup file not found: {backup_path}")
                return False
            
            shutil.copy2(backup_path, file_path)
            self.logger.info(f"Restored {file_path} from backup {backup_path}")
            return True
            
        except Exception as e:
            self.logger.error(f"Error restoring from backup: {e}")
            return False
    
    def get_file_context(self, file_path: str, line_number: int, 
                        context_lines: int = 5) -> str:
        """Get context around a specific line for better LLM understanding"""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                lines = f.readlines()
            
            start_line = max(0, line_number - context_lines - 1)
            end_line = min(len(lines), line_number + context_lines)
            
            context = []
            for i, line in enumerate(lines[start_line:end_line], start=start_line + 1):
                marker = ">>>" if i == line_number else "   "
                context.append(f"{marker} {i:3d}: {line.rstrip()}")
            
            return '\n'.join(context)
            
        except Exception as e:
            self.logger.error(f"Error getting file context: {e}")
            return ""
    
    def apply_function_replacement(self, file_path: str, function_info, 
                                 new_function_code: str) -> EditResult:
        """
        Replace an entire function with new code.
        
        Args:
            file_path: Path to the file to edit
            function_info: FunctionInfo object containing function details
            new_function_code: Complete new function code
            
        Returns:
            EditResult indicating success/failure
        """
        try:
            # Create backup first
            backup_path = self.create_backup(file_path)
            
            # Read original file
            with open(file_path, 'r', encoding='utf-8') as f:
                original_lines = f.readlines()
            
            # Extract the original function lines
            start_line = function_info.start_line - 1  # Convert to 0-indexed
            end_line = function_info.end_line - 1      # Convert to 0-indexed
            
            if start_line < 0 or end_line >= len(original_lines):
                return EditResult(
                    success=False,
                    file_path=file_path,
                    changes_made=False,
                    backup_path=backup_path,
                    error=f"Function lines {function_info.start_line}-{function_info.end_line} out of range"
                )
            
            # Clean the new function code
            cleaned_new_code = self._clean_function_code(new_function_code)
            
            # Get the indentation of the original function
            original_function_line = original_lines[start_line]
            original_indent = len(original_function_line) - len(original_function_line.lstrip())
            
            # Apply the same indentation to the new function
            indented_new_function = self._apply_indentation(cleaned_new_code, original_indent)
            
            # Replace the function in the file
            new_lines = (
                original_lines[:start_line] + 
                [indented_new_function + '\n'] + 
                original_lines[end_line + 1:]
            )
            
            new_content = ''.join(new_lines)
            
            # Validate syntax if it's a Python file
            if file_path.endswith('.py') and self.validate_syntax:
                is_valid, syntax_error = self.validate_python_syntax(new_content)
                if not is_valid:
                    return EditResult(
                        success=False,
                        file_path=file_path,
                        changes_made=False,
                        backup_path=backup_path,
                        error=f"Function replacement would create syntax error: {syntax_error}"
                    )
            
            # Write the new content
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(new_content)
            
            # Generate diff for logging
            original_content = ''.join(original_lines)
            diff = '\n'.join(difflib.unified_diff(
                original_content.splitlines(keepends=True),
                new_content.splitlines(keepends=True),
                fromfile=f"{file_path} (original)",
                tofile=f"{file_path} (modified)",
                lineterm=""
            ))
            
            self.logger.info(f"Successfully replaced function {function_info.name} in {file_path}")
            return EditResult(
                success=True,
                file_path=file_path,
                changes_made=True,
                backup_path=backup_path,
                diff=diff
            )
            
        except Exception as e:
            error_msg = f"Error replacing function: {e}"
            self.logger.error(error_msg)
            return EditResult(
                success=False,
                file_path=file_path,
                changes_made=False,
                error=error_msg
            )
    
    def _clean_function_code(self, function_code: str) -> str:
        """Clean the function code from LLM response"""
        # Remove markdown code blocks
        function_code = re.sub(r'^```python\s*\n', '', function_code, flags=re.MULTILINE)
        function_code = re.sub(r'\n```\s*$', '', function_code, flags=re.MULTILINE)

        # Remove any leading/trailing whitespace but preserve internal structure
        lines = function_code.split('\n')

        first_line_idx = next((i for i, line in enumerate(lines) if line.strip()), 0)
        # Remove empty lines at the beginning and end
        while lines and not lines[0].strip():
            lines.pop(0)
        while lines and not lines[-1].strip():
            lines.pop()

        return '\n'.join(lines)
    
    def _apply_indentation(self, code: str, base_indent: int) -> str:
        """Apply base indentation to code while preserving relative indentation"""
        lines = code.split('\n')
        
        # Find the minimum indentation in the code (excluding empty lines)
        min_indent = float('inf')
        for line in lines:
            if line.strip():  # Skip empty lines
                line_indent = len(line) - len(line.lstrip())
                min_indent = min(min_indent, line_indent)
        
        if min_indent == float('inf'):
            min_indent = 0
        
        # Apply the base indentation
        indented_lines = []
        for line in lines:
            if line.strip():  # Non-empty line
                # Remove the minimum indentation and add the base indentation
                relative_indent = len(line) - len(line.lstrip()) - min_indent
                new_line = ' ' * int(base_indent + relative_indent) + line.lstrip()
                indented_lines.append(new_line)
            else:
                # Keep empty lines as is
                indented_lines.append(line)
        
        return '\n'.join(indented_lines)
    
    def apply_enhanced_function_replacement(self, file_path: str, function_info, 
                                          new_function_code: str, preserve_context: bool = True) -> EditResult:
        """
        Enhanced function replacement with better formatting preservation.
        
        Args:
            file_path: Path to the file to edit
            function_info: FunctionInfo object containing function details
            new_function_code: Complete new function code
            preserve_context: Whether to preserve the original formatting context
            
        Returns:
            EditResult indicating success/failure
        """
        try:
            # Create backup first
            backup_path = self.create_backup(file_path)
            
            # Read original file
            with open(file_path, 'r', encoding='utf-8') as f:
                original_lines = f.readlines()
            
            # Extract the original function lines
            start_line = function_info.start_line - 1  # Convert to 0-indexed
            end_line = function_info.end_line - 1      # Convert to 0-indexed
            
            if start_line < 0 or end_line >= len(original_lines):
                return EditResult(
                    success=False,
                    file_path=file_path,
                    changes_made=False,
                    backup_path=backup_path,
                    error=f"Function lines {function_info.start_line}-{function_info.end_line} out of range"
                )
            
            # Clean the new function code
            cleaned_new_code = self._clean_function_code(new_function_code)
            
            # Analyze the original context for better formatting
            context_info = self._analyze_function_context(original_lines, function_info)
            
            # Apply enhanced indentation based on context
            indented_new_function = self._apply_enhanced_indentation(
                cleaned_new_code, context_info
            )
            
            # Replace the function in the file
            new_lines = (
                original_lines[:start_line] + 
                [indented_new_function + '\n'] + 
                original_lines[end_line + 1:]
            )
            
            new_content = ''.join(new_lines)
            
            # Validate syntax if it's a Python file
            if file_path.endswith('.py') and self.validate_syntax:
                is_valid, syntax_error = self.validate_python_syntax(new_content)
                if not is_valid:
                    return EditResult(
                        success=False,
                        file_path=file_path,
                        changes_made=False,
                        backup_path=backup_path,
                        error=f"Enhanced function replacement would create syntax error: {syntax_error}"
                    )
            
            # Write the new content
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(new_content)
            
            # Generate diff for logging
            original_content = ''.join(original_lines)
            diff = '\n'.join(difflib.unified_diff(
                original_content.splitlines(keepends=True),
                new_content.splitlines(keepends=True),
                fromfile=f"{file_path} (original)",
                tofile=f"{file_path} (modified)",
                lineterm=""
            ))
            
            self.logger.info(f"Successfully replaced function {function_info.name} with enhanced formatting in {file_path}")
            return EditResult(
                success=True,
                file_path=file_path,
                changes_made=True,
                backup_path=backup_path,
                diff=diff
            )
            
        except Exception as e:
            error_msg = f"Error in enhanced function replacement: {e}"
            self.logger.error(error_msg)
            return EditResult(
                success=False,
                file_path=file_path,
                changes_made=False,
                error=error_msg
            )
    
    def _analyze_function_context(self, original_lines: List[str], function_info) -> Dict:
        """Analyze the context around a function for better formatting preservation"""
        context = {
            'base_indent': 0,
            'is_class_method': function_info.is_method,
            'class_name': function_info.class_name,
            'preceding_blank_lines': 0,
            'following_blank_lines': 0,
            'has_decorators': False,
            'decorator_indent': 0
        }

        start_idx = function_info.start_line - 1  # Convert to 0-indexed

        # Analyze the function definition line for base indentation
        if start_idx < len(original_lines):
            func_line = original_lines[start_idx]
            context['base_indent'] = len(func_line) - len(func_line.lstrip())

        # Check for decorators above the function
        decorator_start = start_idx
        for i in range(decorator_start - 1, -1, -1):
            line = original_lines[i].strip()
            if line.startswith('@'):
                context['has_decorators'] = True
                decorator_start = i
                context['decorator_indent'] = len(original_lines[i]) - len(original_lines[i].lstrip())
            elif line == '':
                continue  # Skip blank lines
            else:
                break  # Found non-decorator, non-blank line

        # Count preceding blank lines (after decorators if any)
        for i in range(decorator_start - 1, -1, -1):
            if original_lines[i].strip() == '':
                context['preceding_blank_lines'] += 1
            else:
                break

        # Count following blank lines
        end_idx = function_info.end_line - 1
        for i in range(end_idx + 1, len(original_lines)):
            if original_lines[i].strip() == '':
                context['following_blank_lines'] += 1
            else:
                break

        return context
    
    def _apply_enhanced_indentation(self, code: str, context_info: Dict) -> str:
        """Apply enhanced indentation based on function context"""
        lines = code.split('\n')
        base_indent = context_info['base_indent']

        if not context_info['has_decorators']:
            # Standard indentation application
            return self._apply_indentation(code, base_indent)
        # Look for decorators in the new code
        decorator_lines = []
        function_lines = []

        in_decorators = True
        for line in lines:
            stripped = line.strip()
            if stripped.startswith('@') and in_decorators:
                decorator_lines.append(line)
            elif stripped.startswith('def ') or stripped.startswith('async def '):
                in_decorators = False
                function_lines.append(line)
            else:
                function_lines.append(line)

        # Apply indentation to decorators and function separately
        indented_decorators = []
        for decorator in decorator_lines:
            if decorator.strip():
                indented_decorators.append(' ' * base_indent + decorator.lstrip())
            else:
                indented_decorators.append(decorator)

        # Apply standard indentation to function
        indented_function = self._apply_indentation('\n'.join(function_lines), base_indent)

            # Combine decorators and function
        return (
            '\n'.join(indented_decorators) + '\n' + indented_function
            if indented_decorators
            else indented_function
        )

    def apply_code_block_replacement(self, file_path: str, start_line: int, 
                                   end_line: int, new_code: str) -> EditResult:
        """
        Replace a specific code block (range of lines) with new code.
        This is more efficient than replacing entire functions.
        
        Args:
            file_path: Path to the file to edit
            start_line: Starting line number (1-indexed)
            end_line: Ending line number (1-indexed)
            new_code: New code to replace the block
            
        Returns:
            EditResult indicating success/failure
        """
        try:
            # Create backup first
            if self.create_backups:
                backup_path = self.create_backup(file_path)
                self.logger.info(f"Created backup: {backup_path}")
            else:
                backup_path = None
            
            # Read the file
            with open(file_path, 'r', encoding='utf-8') as f:
                lines = f.readlines()
            
            # Store original content for validation
            original_content = ''.join(lines)
            
            # Validate line numbers
            if start_line < 1 or end_line > len(lines) or start_line > end_line:
                return EditResult(
                    success=False,
                    file_path=file_path,
                    changes_made=False,
                    error=f"Invalid line range: {start_line}-{end_line} (file has {len(lines)} lines)"
                )
            
            # Extract existing indentation from the first line being replaced
            if start_line <= len(lines):
                original_line = lines[start_line - 1]
                base_indent = len(original_line) - len(original_line.lstrip())
            else:
                base_indent = 0
            
            # Process the new code to maintain proper indentation
            new_code_lines = new_code.split('\n')
            if new_code_lines and new_code_lines[-1] == '':
                new_code_lines.pop()  # Remove trailing empty line
            
            # Find the minimum indentation in the new code (excluding empty lines)
            min_indent = float('inf')
            for line in new_code_lines:
                if line.strip():  # Non-empty line
                    line_indent = len(line) - len(line.lstrip())
                    min_indent = min(min_indent, line_indent)
            
            if min_indent == float('inf'):
                min_indent = 0
            
            # Apply consistent indentation to new code, preserving relative indentation
            indented_new_lines = []
            for line in new_code_lines:
                if line.strip():  # Non-empty line
                    # Remove the minimum indentation and apply base indentation
                    relative_indent = len(line) - len(line.lstrip()) - min_indent
                    indented_line = ' ' * int(base_indent + relative_indent) + line.lstrip()
                    indented_new_lines.append(indented_line + '\n')
                else:
                    indented_new_lines.append('\n')  # Preserve empty lines
            
            # Replace the specified line range
            new_file_lines = (
                lines[:start_line-1] +           # Lines before the block
                indented_new_lines +             # New code block
                lines[end_line:]                 # Lines after the block
            )
            
            # Write the modified file
            with open(file_path, 'w', encoding='utf-8') as f:
                f.writelines(new_file_lines)
            
            # Validate syntax if enabled and it's a Python file
            if self.validate_syntax and file_path.endswith('.py'):
                new_content = ''.join(new_file_lines)
                is_valid, syntax_error = self.validate_python_syntax(new_content)
                if not is_valid:
                    # Restore from backup if syntax is invalid
                    if self.create_backups and backup_path:
                        self.restore_from_backup(file_path, backup_path)
                    return EditResult(
                        success=False,
                        file_path=file_path,
                        changes_made=False,
                        backup_path=backup_path,
                        error=f"Code block replacement created syntax error: {syntax_error}"
                    )
            
            # Post-edit validation: Verify the changes were actually applied
            with open(file_path, 'r', encoding='utf-8') as f:
                final_content = f.read()
            
            if final_content == original_content:
                self.logger.error("POST-EDIT VALIDATION FAILED: File content unchanged after edit!")
                # Restore from backup
                if self.create_backups and backup_path:
                    self.restore_from_backup(file_path, backup_path)
                return EditResult(
                    success=False,
                    file_path=file_path,
                    changes_made=False,
                    backup_path=backup_path,
                    error="Post-edit validation failed: File content was not modified"
                )
            
            # Generate diff for logging
            diff = self._generate_diff(original_content, final_content, file_path)
            
            self.logger.info(f"Successfully replaced code block (lines {start_line}-{end_line}) in {file_path}")
            self.logger.info(f"Post-edit validation passed: {len(final_content)} characters written")
            
            return EditResult(
                success=True,
                file_path=file_path,
                changes_made=True,
                backup_path=backup_path,
                diff=diff
            )
            
        except Exception as e:
            self.logger.error(f"Error in code block replacement: {e}")
            return EditResult(
                success=False,
                file_path=file_path,
                changes_made=False,
                error=str(e)
            )
    
    def _should_use_semantic_edit(self, file_path: str, old_code: str, new_code: str) -> bool:
        """Determine if semantic editing should be used"""
        try:
            # Use semantic editing for Python files with significant changes
            if not file_path.endswith('.py'):
                return False
            
            # Check if Serena is available
            if not hasattr(self, 'serena_editor') or self.serena_editor is None:
                return False
            
            # Use semantic editing for larger code blocks or function changes
            old_lines = len(old_code.strip().split('\n'))
            new_lines = len(new_code.strip().split('\n'))
            
            # Use semantic editing if the change involves multiple lines or keywords
            return (old_lines > 2 or new_lines > 2 or 
                   any(keyword in old_code + new_code for keyword in 
                       ['def ', 'class ', 'import ', 'from ', 'if ', 'for ', 'while ']))
        
        except Exception as e:
            self.logger.warning(f"Error determining semantic edit usage: {e}")
            return False
    
    def _apply_semantic_edit(self, file_path: str, old_code: str, new_code: str) -> EditResult:
        """Apply semantic editing using Serena"""
        try:
            if not self.use_serena or not self.serena_editor:
                return EditResult(
                    success=False,
                    file_path=file_path,
                    changes_made=False,
                    error="Serena editor not available"
                )
            # Create backup first
            backup_path = self.create_backup(file_path)

            # Use Serena for semantic editing
            from serena_integration import SemanticEdit
            semantic_edit = SemanticEdit(
                operation="replace_symbol_body",
                symbol_name="",  # Will need to be determined based on context
                file_path=file_path,
                new_code=new_code
            )
            if result := self.serena_editor.apply_semantic_edit(semantic_edit):
                self.logger.info("Semantic edit applied successfully")
                return EditResult(
                    success=True,
                    file_path=file_path,
                    changes_made=True,
                    backup_path=backup_path,
                    diff=""  # Serena doesn't provide diff
                )
            else:
                self.logger.warning("Semantic edit failed")
                return EditResult(
                    success=False,
                    file_path=file_path,
                    changes_made=False,
                    backup_path=backup_path,
                    error="Semantic edit operation failed"
                )

        except Exception as e:
            error_msg = f"Error in semantic editing: {e}"
            self.logger.error(error_msg)
            return EditResult(
                success=False,
                file_path=file_path,
                changes_made=False,
                error=error_msg
            )
    
    def _apply_traditional_replacement(self, file_path: str, old_code: str, 
                                     new_code: str, context_lines: int = 3) -> EditResult:
        """Apply traditional string replacement as fallback"""
        try:
            # Create backup first
            self.logger.info("CREATING BACKUP")
            backup_path = self.create_backup(file_path)
            self.logger.info(f"Backup created: {backup_path}")
            
            # Read original file
            self.logger.info("READING ORIGINAL FILE")
            with open(file_path, 'r', encoding='utf-8') as f:
                original_content = f.read()
            self.logger.info(f"File read: {len(original_content)} characters")
            
            # Find and replace the code
            self.logger.info("SEARCHING FOR CODE MATCH")
            if old_code.strip() in original_content:
                # Direct replacement
                self.logger.info("EXACT MATCH FOUND - Applying direct replacement")
                new_content = original_content.replace(old_code.strip(), new_code.strip())
            else:
                # Try fuzzy matching with context
                self.logger.warning("NO EXACT MATCH - Attempting fuzzy matching")
                new_content = self._apply_fuzzy_replacement(original_content, old_code, new_code)
                
                if new_content == original_content:
                    self.logger.error("FUZZY MATCHING FAILED")
                    self.logger.error("Could not find suitable replacement location")
                    return EditResult(
                        success=False,
                        file_path=file_path,
                        changes_made=False,
                        backup_path=backup_path,
                        error="Could not find exact match for code replacement"
                    )
            
            # Validate syntax if it's a Python file
            if file_path.endswith('.py'):
                is_valid, syntax_error = self.validate_python_syntax(new_content)
                if not is_valid:
                    return EditResult(
                        success=False,
                        file_path=file_path,
                        changes_made=False,
                        backup_path=backup_path,
                        error=f"Syntax validation failed: {syntax_error}"
                    )
            
            # Write the modified content
            self.logger.info("WRITING MODIFIED CONTENT")
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(new_content)
            self.logger.info(f"File written: {len(new_content)} characters")
            
            # Generate diff for logging
            self.logger.info("GENERATING DIFF")
            diff = self._generate_diff(original_content, new_content, file_path)
            
            self.logger.info("CHANGES MADE:")
            self.logger.info("-" * 60)
            self.logger.info(diff[:1000] + ("..." if len(diff) > 1000 else ""))
            self.logger.info("-" * 60)
            
            self.logger.info("CODE REPLACEMENT COMPLETED SUCCESSFULLY")
            self.logger.info("=" * 80)
            
            return EditResult(
                success=True,
                file_path=file_path,
                changes_made=True,
                backup_path=backup_path,
                diff=diff
            )
            
        except Exception as e:
            error_msg = f"Error applying code replacement: {e}"
            self.logger.error(error_msg)
            return EditResult(
                success=False,
                file_path=file_path,
                changes_made=False,
                error=error_msg
            )

    
    def edit_file_content_serena(self, file_path: str, optimized_code: str, context: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """Edit file content using Serena semantic editing or fallback to traditional methods"""
        try:
            self.logger.info(f"[SERENA] Attempting semantic edit for {file_path}")

            # Check if Serena is available and properly initialized
            if hasattr(self, 'serena_client') and self.serena_client and self.serena_editor:
                try:
                    # Use Serena's semantic editing capabilities
                    original_code = context.get('original_code', '') if isinstance(context, dict) else ''
                    serena_result = self._apply_semantic_edit(file_path, original_code, optimized_code)
                    if serena_result.success:
                        self.logger.info("[SERENA] Successfully applied semantic edit")
                        return {
                            'success': True,
                            'file_path': file_path,
                            'changes_made': True,
                            'backup_path': serena_result.backup_path,
                            'diff': serena_result.diff
                        }
                    else:
                        self.logger.warning(f"[SERENA] Semantic edit failed: {serena_result.error}")
                except Exception as e:
                    self.logger.warning(f"[SERENA] Error during semantic edit: {e}")

            # Evaluate strategies (AST, Serena, snippet replacement, regex by name), then apply in ranked order
            self.logger.info("[EVAL] Evaluating edit strategies for best accuracy")
            ranked = self._evaluate_edit_strategies(file_path, optimized_code, context)
            for strategy in ranked:
                self.logger.info(f"[EVAL] Trying strategy: {strategy['name']} (score={strategy['score']:.2f})")
                apply_func = strategy['apply']
                try:
                    apply_result = apply_func()
                    if isinstance(apply_result, dict) and apply_result.get('success'):
                        return apply_result
                    if isinstance(apply_result, EditResult) and apply_result.success:
                        return {
                            'success': True,
                            'file_path': apply_result.file_path,
                            'changes_made': apply_result.changes_made,
                            'backup_path': apply_result.backup_path,
                            'diff': apply_result.diff
                        }
                except Exception as e:
                    self.logger.warning(f"[EVAL] Strategy {strategy['name']} failed: {e}")

            # If all strategies failed, return a safe failure
            self.logger.info(
                "[FALLBACK] Using targeted replacement (no full-file overwrite)"
            )
            try:
                # Create backup first for safety
                backup_path = self.create_backup(file_path)

                # Read original file
                with open(file_path, 'r', encoding='utf-8') as f:
                    original_content = f.read()

                # 1) If caller provided original_code snippet, perform targeted replacement
                if isinstance(context, dict) and context.get('original_code'):
                    snippet = context['original_code']
                    result = self._apply_traditional_replacement(
                        file_path=file_path,
                        old_code=snippet,
                        new_code=optimized_code,
                        context_lines=3
                    )
                    return {
                        'success': result.success,
                        'method': 'targeted_replacement_with_context',
                        'file_path': result.file_path,
                        'changes_made': result.changes_made,
                        'backup_path': result.backup_path,
                        'error': result.error,
                        'diff': result.diff
                    }

                # 2) Try function/class scoped replacement if we can detect a name
                import re
                func_match = re.search(r"^\s*def\s+(\w+)\s*\(", optimized_code, flags=re.MULTILINE)
                class_match = re.search(r"^\s*class\s+(\w+)\s*\(", optimized_code, flags=re.MULTILINE)

                if func_match:
                    name = func_match[1]
                    # Attempt to replace the entire function definition by name
                    pattern = re.compile(rf"(^\s*def\s+{name}\s*\(.*?\):[\s\S]*?)(?=^\S|\Z)", re.MULTILINE)
                    if pattern.search(original_content):
                        new_content = pattern.sub(optimized_code.strip() + "\n\n", original_content)
                        # Validate syntax if python file
                        if file_path.endswith('.py'):
                            ok, err = self.validate_python_syntax(new_content)
                            if not ok:
                                return {
                                    'success': False,
                                    'error': f'Syntax validation failed after function replacement: {err}',
                                    'backup_path': backup_path
                                }
                        with open(file_path, 'w', encoding='utf-8') as f:
                            f.write(new_content)
                        return {
                            'success': True,
                            'method': 'function_replacement_by_name',
                            'backup_path': backup_path
                        }

                if class_match:
                    name = class_match[1]
                    pattern = re.compile(rf"(^\s*class\s+{name}\s*\(.*?\):[\s\S]*?)(?=^\S|\Z)", re.MULTILINE)
                    if pattern.search(original_content):
                        new_content = pattern.sub(optimized_code.strip() + "\n\n", original_content)
                        if file_path.endswith('.py'):
                            ok, err = self.validate_python_syntax(new_content)
                            if not ok:
                                return {
                                    'success': False,
                                    'error': f'Syntax validation failed after class replacement: {err}',
                                    'backup_path': backup_path
                                }
                        with open(file_path, 'w', encoding='utf-8') as f:
                            f.write(new_content)
                        return {
                            'success': True,
                            'method': 'class_replacement_by_name',
                            'backup_path': backup_path
                        }

                # 3) As a last resort, do NOT overwrite the whole file; return a safe failure
                return {
                    'success': False,
                    'error': 'No safe targeted replacement strategy available; refusing to overwrite entire file',
                    'original_size': len(original_content),
                    'optimized_size': len(optimized_code),
                    'backup_path': backup_path
                }

            except Exception as e:
                return {
                    'success': False,
                    'error': f"Traditional file replacement failed: {e}"
                }

        except Exception as e:
            return {
                'success': False,
                'error': f"File content editing failed: {e}"
            }

    # ----------------------- Strategy Evaluation & AST Replacement -----------------------
    def _evaluate_edit_strategies(self, file_path: str, optimized_code: str, context: Optional[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Evaluate available editor strategies and return them ranked by an accuracy score.

        Strategies assessed:
          - AST-targeted replacement (highest precision on symbol boundaries)
          - Serena semantic edit (if available)
          - Context snippet replacement (traditional)
          - Regex function/class replacement by name
        """
        strategies: List[Dict[str, Any]] = []

        # Helper to simulate a strategy without writing by validating syntax
        def simulate_edit(new_content: str) -> float:
            if file_path.endswith('.py'):
                ok, _ = self.validate_python_syntax(new_content)
                return 1.0 if ok else 0.0
            return 0.8  # non-py files: assume moderate confidence

        # Load current content
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                original = f.read()
        except Exception:
            original = ""

        # Strategy A: AST-targeted replacement
        def apply_ast():
            return self._apply_ast_targeted_replacement(file_path, optimized_code, context)

        ast_score = 0.0
        try:
            sim = self._simulate_ast_apply(original, optimized_code, context)
            if sim is not None:
                ast_score = simulate_edit(sim)
        except Exception:
            ast_score = 0.0
        strategies.append({'name': 'AST-targeted', 'score': ast_score or 0.7, 'apply': apply_ast})

        # Strategy B: Serena semantic editing (if available)
        def apply_serena():
            if hasattr(self, 'serena_client') and self.serena_client and self.serena_editor:
                original_code = context.get('original_code', '') if isinstance(context, dict) else ''
                res = self._apply_semantic_edit(file_path, original_code, optimized_code)
                return res
            return {'success': False, 'error': 'Serena not available'}

        serena_score = 0.85 if (self.use_serena and self.serena_editor) else 0.0
        strategies.append({'name': 'Serena-semantic', 'score': serena_score, 'apply': apply_serena})

        # Strategy C: Context snippet replacement
        def apply_context_snippet():
            if isinstance(context, dict) and context.get('original_code'):
                return self._apply_traditional_replacement(file_path, context['original_code'], optimized_code, 3)
            return {'success': False, 'error': 'No original_code snippet provided'}

        # Simulate if possible
        ctx_score = 0.0
        if isinstance(context, dict) and context.get('original_code') and original and context['original_code'] in original:
            ctx_score = 0.9
        strategies.append({'name': 'Snippet-replacement', 'score': ctx_score, 'apply': apply_context_snippet})

        # Strategy D: Regex function/class name replacement
        import re
        def_name = re.search(r"^\s*def\s+(\w+)\s*\(", optimized_code, flags=re.MULTILINE)
        cls_name = re.search(r"^\s*class\s+(\w+)\s*\(", optimized_code, flags=re.MULTILINE)
        def apply_regex_by_name():
            # attempt within this function using current original content
            if not original:
                return {'success': False, 'error': 'No original content'}
            name = def_name[1] if def_name else cls_name[1] if cls_name else None
            if not name:
                return {'success': False, 'error': 'No function/class name detected'}
            pattern = re.compile(rf"(^\s*(def|class)\s+{name}\b[\s\S]*?)(?=^\S|\Z)", re.MULTILINE)
            if not pattern.search(original):
                return {'success': False, 'error': 'Pattern not found'}
            new_content = pattern.sub(optimized_code.strip() + "\n\n", original)
            # Validate
            if file_path.endswith('.py'):
                ok, err = self.validate_python_syntax(new_content)
                if not ok:
                    return {'success': False, 'error': f'Syntax failed: {err}'}
            # Actually write
            backup_path = self.create_backup(file_path)
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(new_content)
            return {'success': True, 'method': 'regex_by_name', 'backup_path': backup_path}

        regex_score = 0.7 if (def_name or cls_name) else 0.0
        strategies.append({'name': 'Regex-by-name', 'score': regex_score, 'apply': apply_regex_by_name})

        # Rank by score (desc)
        strategies.sort(key=lambda s: s['score'], reverse=True)
        return strategies

    def _simulate_ast_apply(self, original_content: str, optimized_code: str, context: Optional[Dict[str, Any]]) -> Optional[str]:
        """Simulate AST-based replacement and return new content string without writing, or None if not applicable."""
        target_name = context.get('target_name') if isinstance(context, dict) else None
        import re
        if not target_name:
            if m := re.search(
                r"^\s*def\s+(\w+)\s*\(", optimized_code, flags=re.MULTILINE
            ):
                target_name = m[1]
            else:
                if m := re.search(
                    r"^\s*class\s+(\w+)\s*\(", optimized_code, flags=re.MULTILINE
                ):
                    target_name = m[1]
        if not target_name:
            return None

        try:
            tree = ast.parse(original_content)
        except Exception:
            return None

        node = next(
            (
                n
                for n in ast.walk(tree)
                if isinstance(
                    n, (ast.FunctionDef, ast.AsyncFunctionDef, ast.ClassDef)
                )
                and getattr(n, 'name', None) == target_name
            ),
            None,
        )
        if not node or not hasattr(node, 'lineno') or not hasattr(node, 'end_lineno'):
            return None

        # Ensure we replace with the precise symbol body from optimized_code
        # If optimized_code contains a larger scope (e.g., full class) but target is a method,
        # extract only the target symbol from optimized_code to avoid nesting classes erroneously.
        extracted = self._extract_symbol_source(optimized_code, target_name)
        replacement_code = extracted or optimized_code

        # Compute decorator-inclusive start
        lines = original_content.split('\n')
        start = node.lineno - 1
        # include decorators above
        i = start - 1
        while i >= 0 and lines[i].lstrip().startswith('@'):
            start = i
            i -= 1
        end = node.end_lineno  # exclusive when slicing lines list

        # Preserve indentation of original block
        indent_prefix = ''
        orig_line = lines[start]
        indent_prefix = orig_line[:len(orig_line) - len(orig_line.lstrip())]
        indented_new = '\n'.join(indent_prefix + ln if ln.strip() else ln for ln in replacement_code.strip().split('\n'))

        new_lines = lines[:start] + [indented_new] + lines[end:]
        return '\n'.join(new_lines)

    def _extract_symbol_source(self, code: str, name: str) -> Optional[str]:
        """Extract the exact source lines for a function/method/class with the given name from code.

        Returns the code including decorators directly above the symbol. If not found, returns None.
        """
        try:
            tree = ast.parse(code)
        except Exception:
            return None

        target = next(
            (
                n
                for n in ast.walk(tree)
                if isinstance(
                    n, (ast.FunctionDef, ast.AsyncFunctionDef, ast.ClassDef)
                )
                and getattr(n, 'name', None) == name
            ),
            None,
        )
        if not target or not hasattr(target, 'lineno') or not hasattr(target, 'end_lineno'):
            return None

        lines = code.split('\n')
        start = target.lineno - 1
        # include decorators immediately above
        i = start - 1
        while i >= 0 and lines[i].lstrip().startswith('@'):
            start = i
            i -= 1
        end = target.end_lineno
        snippet = '\n'.join(lines[start:end])
        # Normalize indentation by removing common leading spaces
        # Determine minimum indent of non-empty lines
        non_empty = [ln for ln in snippet.split('\n') if ln.strip()]
        if not non_empty:
            return snippet
        min_indent = min(len(ln) - len(ln.lstrip()) for ln in non_empty)
        return '\n'.join(
            ln[min_indent:] if ln.strip() else ln for ln in snippet.split('\n')
        )

    def _apply_ast_targeted_replacement(self, file_path: str, optimized_code: str, context: Optional[Dict[str, Any]]) -> Dict[str, Any]:
        """Apply AST-targeted replacement by symbol name, preserving decorators and indentation."""
        # Read original
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                original_content = f.read()
        except Exception as e:
            return {'success': False, 'error': f'Failed to read file: {e}'}

        new_content = self._simulate_ast_apply(original_content, optimized_code, context)
        if not new_content:
            return {'success': False, 'error': 'AST targeting not applicable'}

        # Validate syntax if python
        if file_path.endswith('.py'):
            ok, err = self.validate_python_syntax(new_content)
            if not ok:
                return {'success': False, 'error': f'Syntax validation failed after AST replacement: {err}'}

        # Backup and write
        backup_path = self.create_backup(file_path)
        try:
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(new_content)
            return {
                'success': True,
                'method': 'ast_targeted',
                'backup_path': backup_path
            }
        except Exception as e:
            return {'success': False, 'error': f'Failed to write file: {e}', 'backup_path': backup_path}
